<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDP Line Simplification</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>Draw on the canvas</h1>
    <canvas id="drawingCanvas" width="800" height="600"></canvas>
    <div>
    <label for="epsilon">Epsilon:</label>
    <input type="number" id="epsilon" value="5.0" step="0.1">
    <br>
    <button id="simplifyButton">Simplify</button>
    </div>
    <script type="module">

        import init, { simplify_rdp } from "./rust/pkg/rdp.js";
        import { rdp } from "./js/rdp.js"

        async function run() {
            await init();
            console.log("Library initialized.")

            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            let drawing = false;
            let points = [];

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mousemove', draw);
            document.getElementById('simplifyButton').addEventListener('click', simplifyDrawing);

            function startDrawing(event) {
                drawing = true;
                points.push(getMousePos(canvas, event));
            }

            function stopDrawing() {
                drawing = false;
                ctx.beginPath();
            }

            function draw(event) {
                if (!drawing) return;
                const pos = getMousePos(canvas, event);
                points.push(pos);
                ctx.lineTo(pos[0], pos[1]);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(pos[0], pos[1]);
            }

            function getMousePos(canvas, event) {
                const rect = canvas.getBoundingClientRect();
                return [event.clientX - rect.left, event.clientY - rect.top];
            }

            function getPerpendicularDistance(point, lineStart, lineEnd) {
                const [x, y] = point;
                const [x1, y1] = lineStart;
                const [x2, y2] = lineEnd;

                const area = Math.abs((x2 - x1) * (y1 - y) - (x1 - x) * (y2 - y1));
                const base = Math.hypot(x2 - x1, y2 - y1);
                return area / base;
            }


            function simplifyDrawing() {
                const epsilon = parseFloat(document.getElementById('epsilon').value);
                console.log("Input: ", points);
                const simplifiedPoints = rdp(points, epsilon);
                console.log("Output: ",simplifiedPoints);

                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Redraw the simplified points
                ctx.beginPath();
                for (let i = 0; i < simplifiedPoints.length; i++) {
                    const [x, y] = simplifiedPoints[i];
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Reset points to the simplified version
                points = simplifiedPoints;
            }
    }
    run();
    </script>
</body>
</html>
